


### 线程安全性 ###

构建稳定的并发程序时，必正确的使用线程和锁。但这终归只是一些机制。要**编写线程安全的代码的核心**在于要对**状态访问操作**进行管理，特别是对**共享的** 和 **可变的状态**的访问。



> **共享**意味着变量可以由多个线程同时访问，而**可变**意味着变量的值在其生命周期内是可以发生变化的。

一个对象是否需要是线程安全的，取决于它是否被多个线程访问。要使得对象是线程安全的，就需要采用同步机制来**协同**对对象可变状态的访问。如果无法实现协同，那么可能会导致数据破坏以及其他不该出现的结果。

当有**多个线程访问某个状态变量** 并且其中 **一个线程执行写入操作**时，必须采取同步机制来协同这些线程对变量的访问。



> Java中的主要同步机制是关键字**synchronized**，它提供了一种独占加锁方式。除了这些，**“同步”** 这个术语还包括 **volatile** 类型的变量，**显示锁（Explicit Lock）** 以及原子变量。

如果当多个线程访问同一个可变的状态变量时没有使用合适的同步，那么程序就会出现错误。有三种方式可以修复这个问题：

- 不在线程之间共享该状态变量
- 将状态变量修改为不可变的变量
- 在访问状态变量时使用同步
 
当设计线程安全的类时，良好的面向对象技术、不可修改性，以及明晰的不变性规范都能起到一定的帮助作用。

到目前为止，我们使用了“线程安全类”和“线程安全程序”这两个术语。二者的含义基本相同。

线程安全的程序是否完全有线程安全类构成？答案是否定的，完全有线程安全类构成的程序并不一定就是线程安全的，而在线程安全类中也可以包含非线程安全的类。

#### 什么是线程安全 ####



> 当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为，那么就称这个类时线程安全的。

在线程安全性的定义中，最核心的概念就是正确性。

正确性的含义是：某个类的行为与其规范完全一致。在良好的规范中通常会定义各种**不变性**来约束对象的状态，以及定义各种 **后验条件**来描述对象操作的结果。 

由于我们通常不会为类编写详细的规范，那么如何知道这些类是否正确呢？这里我们引入这样一个理论，即将单线程的正确性近义定义为**“所见即所知（we know it when we see it）”**。

在对**“正确性”** 给出了一个较为清晰的定义后，就可以定义线程安全性：**当多个线程访问某个类时，这个类始终都能表现出正确的行为，那么就称这个类时线程安全的。**

> 在线程安全类中封装了必要的同步机制，因此客户端无须进一步采取同步措施。

**无状态对象一定是线程安全的**

#### 原子性 ####


- 竞态条件



- 示例：延迟初始化中的竞态条件



- 复合操作




#### 加锁机制 ####



- 内置锁



- 重入






#### 用锁来保护状态 ####








#### 活跃性与性能 ####















